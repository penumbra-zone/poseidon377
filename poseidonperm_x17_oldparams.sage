# Modified from Appendix B in the Poseidon paper, width 3 hash for BLS12-377
# Testing the old parameter set
import time

# M = 128
alpha = 17
t = 3
prime = 8444461749428370424248824938781546531375899335154063827935233455917409239041
F = GF(prime)
R_P = 31
R_F = 8
R_f = R_F / 2
R_T = R_F + R_P

round_constants = [4142789024066682058007045609495225080310439232397020447581643283020402654846, 
6409539797364261710552581321458029610407131037792921818391550494400966887624, 
434644021451189914185018744948313484129805290895594447443052237281550828302, 
3978232313779409461010821071459237774651528475886330761645280386215988622552, 
7027675418691353855077049716619550622043312043660992344940177187528247727783, 
7189549166770373741329731605871268725917424160918539735183953407609782310671, 
7392912630620987537830295605300793622705671124264041073963605781672270141915, 
5949536007459518301090366366909069410803066766901970408406849212090540394636,
7535044167388550589656345641705141193619697763422583102570700142917926460746, 
1895787744275032126969510915721097499434363776951852141553831406798712945249,
4780490314493880536687998802667427160888142414946926741509958608649897801961,
8372126916059111954256092325074913739667089775869134773945147503316973649611,
6014855836494873623351975581130370543367648859926578635364092627872598058412,
3345904483218983873193806399382582517770045178367157384303058269833083252754,
902087393777457366603907370284575597015462970269503048717648569756113584039,
7190292550318276214398313552808394584790419061886470473988181973281343780757,
2610765984066308393328114391595595723956099462161539001836037600787237342384,
5917746701105510628296061540376727068393075936267928775806949883353156098050,
1544120197157255725054202969493775698265372148512362695186457816885198764098,
3154601528146586191529805548895490825439257316824950761721374935254450017105,
5632040662872487587088101375050520442085231006715959318713341318343750456309,
7305041445486140093866580689821947718515178869228669546867030124027259187237,
3985620461395645128883896772044359019642804503332145037015836308089888590232,
5039838231944825776917897441608048242186213927155500306890152810848341974812,
3601569678245788527706695813801670388961127510634220552844343654739492644695,
205234288395557346749214023471536298057388508892446606063903159248460092066,
149101987103211771991327927827692640556911620408176100290586418839323044234,
3435511669910392247548655522227388629020495227124395897496115919202201958423,
3413671667902446892286179771879134444344429300201592934083792160748318246236,
7610952409059668622590203223446160708217928201909920657169231419353643539645,
3200434446862292889208950343401937241201965981880575096216040177190605558173,
8165607313238750369025907849048519202312642949338135644119921631537866844417,
5432282207954394876378030337261908971213608112113615258244119439227843131247,
1344007070255979392542466853284928583582044452937702005039847193909501407981,
2354142521332721574625205886950325892800455590935478848218273452814275325225,
1016937616853600282020208165804160497011769118191177437220523539941902393489,
2002759693851535517568611947407459006773820845919424764626172216377005090547,
2861947517263347664338592979483725573667842634322673654672933613792804505644,
4622082908476410083286670201138165773322781640914243047922441301693321472984,
7848349054307977947753352030830141331999981351248897148565673797917746251243,
2635090520059500019661864086615522409798872905401305311748231832709078452746,
2181843080725597472744243109052445257669852758810629851303719579249798759504,
4177958784543146626512235378267822677604732785747417608457601968708255499485,
4058848833340764581565262962494083335664915551719584286129679497808366647759,
3520810438340381254404690207705223621082909021213561676514038963438057352982,
3706747844008816288380470801735965548950933295920494172932050062353453026013,
8139380413376315759255955331115332089257664354349116941280856523514815105641,
1816333954221186176328804836839709738076547257404691805463013441329538632558,
7340485916200743279276570085958556798507770452421357119145466906520506506342,
2382452598490509367839105573671209204167961481055304382686838286886266207227,
5056115266426728450178391882608195595876171048681268304355720900505776906957,
7221669722700687417346373353960536661883467014204005276831020252277657076044,
6368161538087610648488044291292734422987845922385448383069800148268651909616,
3936277978660994578484624612338287242284761330659507303379888042887209868219,
7553885614632219548127688026174585776320152166623257619763178041781456016062,
7008931647336836592130220075320442774797563550276468470666422499764123409185,
5478929644476681096437469958231489102974161353940993351588559414552523375472,
1528166342661706125388227390767317047300390619784032346502269073828784859200,
5243241660201444889739219719496555878502439466360999397640446334244703048852,
918092522455288617209745099309732321643550165636028720886999342662589364746,
3018896071704599494587678562316946681958395317088821601441890425694787547773,
21760554527324687002357019243073620051486602946257736612673464286111304851,
6617299322445514002670256753901658353257661046330144343159313270124840300407,
513174846394589492892516892292249974753441896224730309466074742328622991941,
4679524488075358285671313014655771919728938318939962505756741845833733230593,
1367639112737052497986932653133836953962145380255827533091418163093538406970,
8387168497757638217267952532627697100644685452179458107510209976445609266655,
3392875491762833488653610406905134081957052665937031177845718708958657914804,
7560689444971407628258476313377878697697205734433871706857763279333824762855,
723689333992989230073849589324114648273889652888418467697254672016492890004,
5891485173249339523379223288448657883700478294815122265518985886600289939700,
2146188678724470135846881017323261926153556509470150842613127280385315423430,
4874880355887353001232208315814285285840262033661322395129791541388175651234,
6168350640451697768990993303883633387387006187609416505118064684947204397304,
6975793621673382674555171252774924917745108889944673072124982713806561725482,
4063907182954603193076687040792392678583619477871363692587216417365070850941,
5788331877803867705100368061803153698509698310757412464009789447320349584469,
7427520624591421856939809538841651140914692972227395081107421685563036894763,
992168360099222192341033444104480564024800663224835956490318239422508684750, 
2224670401791218384750413695729679910214908458419012223524658105202521196140, 
5109134780145832004525124871602216050357012608141737081857351468019559651873,
2032937344817689055000131682336003884359337332986030232471997710678756074664,
3313742863447803033098180403532372330859846221889394191617673726237563262269,
760215077312669098137486704025669959594496562254871635766954058635319433487,
6935839211798937659784055008131602708847374430164859822530563797964932598700,
1673563329605058724105965600771468505923683434977712314158372952755791665101,
7471469164647220837870506637102701363780473070549326874338918292291624353642,
2851596451267806441339266146934956348004863149718852770512501852518014805930,
3513923924281796709536138766376440741552465863472420701988483747756664163934,
97920448917513431649024347496907132618492784195433600281157216153760812696,
1299003891247893574588735065292522607510317390448781519272360611621850856828,
7608831801232295722756959133217262701806829845646062666056135627717658081438,
2796870585100457312812302054449119313570064083051318031219169615811504845127,
4751559102844428649397704183527777787297076012438120696820074559245649646314,
1219439673853113792340300173186247996249367102884530407862469123523013083971,
3157103610619236629936530069231576407066158884828387332210368822678725218535,
2140214921828858149915908823389079352725991448724491879340045030907325055762,
2606721986957561981325245591819707106541029602271159421934957021343675975784,
2587684196724330274503517333583933341997924958480303083909431044880120606449,
1183153629980760549326804634130338079002602968026018500950671963640303476825,
7411068016485402682322825352282479261119183821409417074641042202652468811638,
1616465736651597758295963585608811656583823854813412382746863998755440991074,
833806457669532625158446158460326755462748095512482794504262389143621175351,
4074071340035297571271762272204219396807759100006901378273830785064551485962,
1119979170199325804158233209924637442523082412743565514921850168114631753211,
4325186103785259518614024482753721287729374183895900754002106893726233708024,
1129825494990051748021418145704292652613627009469735504942877650143407249589,
7135275277770998377034556802290955576448219083620429238895247915159267211419,
4770160707215481084533958640215881447408046119948677124503030837587355426221,
7895336590269193028217052369908415014762407680575360282935984241072684273688,
2785695613365936757716092540000556580294975911863773551392460680485060968372, 
6359074816024367983802845581430765434510246278753636966915237021231717896923,
4134751064587747838388129451335439045214823578259625190652109110537710180551,
960580735377423695872994397616108016237844609777393601920435423302156645662,
5178886821817300062676266174379357047892714493964310974731352913024065889396, 
1371117241418934191509604604522211201045829002846073882061151911980190634267,
3593291146070810978435992295622792674102387712222300421717906998730519807699]

MDS_matrix = [[1176051956847107240720092743191536744506212303326360080512163156103164149850, 8402878543642667924723401420033811459284838550048699791113189260852042826292, 4811768985211772890695110403603066421529029662509159174865246530735459231858], 
[5535935393902879129094190749868598276367224136842358849250625741902371918397, 852045520402960286757476806137003380038111134742018251087010944117170670045, 1975757179445587153504332846839733248013115409591135033263127279549863534348],
[7538581871990313094722169407693099586981512115574584706059794064373804072579, 8068228532188099852215410265440892229890017298378596673075865704251484253563, 4490311258785448094966638742404772135519324058760425359537868315201320249319]]

MDS_matrix_field = matrix(F, t, t)

for i in range(0, t):
    for j in range(0, t):
        MDS_matrix_field[i, j] = F(MDS_matrix[i][j])

round_constants_field = []
for i in range(0, (R_F + R_P) * t):
    round_constants_field.append(F(round_constants[i]))

def calc_equivalent_constants(constants):
    constants_temp = [constants[index:index+t] for index in range(0, len(constants), t)]

    MDS_matrix_field_transpose = MDS_matrix_field.transpose()

    # Start moving round constants up
    # Calculate c_i' = M^(-1) * c_(i+1)
    # Split c_i': Add c_i'[0] AFTER the S-box, add the rest to c_i
    # I.e.: Store c_i'[0] for each of the partial rounds, and make c_i = c_i + c_i' (where now c_i'[0] = 0)
    for i in range(R_T - 2 - R_f, R_f - 1, -1):
        inv_cip1 = list(vector(constants_temp[i+1]) * MDS_matrix_field_transpose.inverse())
        constants_temp[i] = list(vector(constants_temp[i]) + vector([0] + inv_cip1[1:]))
        constants_temp[i+1] = [inv_cip1[0]] + [0] * (t-1)

    return constants_temp

def calc_equivalent_matrices():
    # Following idea: Split M into M' * M'', where M'' is "cheap" and M' can move before the partial nonlinear layer
    # The "previous" matrix layer is then M * M'. Due to the construction of M', the M[0,0] and v values will be the same for the new M' (and I also, obviously)
    # Thus: Compute the matrices, store the w_hat and v_hat values

    MDS_matrix_field_transpose = MDS_matrix_field.transpose()

    w_hat_collection = []
    v_collection = []
    v = MDS_matrix_field_transpose[[0], list(range(1,t))]
    M_mul = MDS_matrix_field_transpose
    M_i = matrix(F, t, t)
    for i in range(R_P - 1, -1, -1):
        M_hat = M_mul[list(range(1,t)), list(range(1,t))]
        w = M_mul[list(range(1,t)), [0]]
        v = M_mul[[0], list(range(1,t))]
        v_collection.append(v.list())
        w_hat = M_hat.inverse() * w
        w_hat_collection.append(w_hat.list())

        # Generate new M_i, and multiplication M * M_i for "previous" round
        M_i = matrix.identity(t)
        M_i[list(range(1,t)), list(range(1,t))] = M_hat
        M_mul = MDS_matrix_field_transpose * M_i
    return [M_i, v_collection, w_hat_collection]

def cheap_matrix_mul(state_words, v, w_hat, M_0_0):
    state_words_new = [0] * t
    column_1 = [M_0_0] + w_hat
    state_words_new[0] = sum([column_1[i] * state_words[i] for i in range(0, t)])
    mul_row = [(state_words[0] * v[i]) for i in range(0, t-1)]
    add_row = [(mul_row[i] + state_words[i+1]) for i in range(0, t-1)]
    state_words_new = [state_words_new[0]] + add_row
    return state_words_new

def perm(input_words):
    round_constants_field_new = calc_equivalent_constants(round_constants_field)
    print(round_constants_field_new)
    [M_i, v_collection, w_hat_collection] = calc_equivalent_matrices()
    # M_i is transpose of Mi
    #print(M_i)
    M_0_0 = MDS_matrix_field[0, 0]
    #print(M_0_0)
    #print(v_collection)
    #[M_i, test_mat] = calc_equivalent_matrices()

    global timer_start, timer_end

    timer_start = time.time()

    R_f = int(R_F / 2)

    round_constants_round_counter = 0

    state_words = list(input_words)

    # First full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Middle partial rounds
    # Initial constants addition
    for i in range(0, t):
        state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]

    # First full matrix multiplication
    state_words = list(vector(state_words) * M_i)

    for r in range(0, R_P):
        # Round constants, nonlinear layer, matrix multiplication
        state_words[0] = (state_words[0])^alpha

        # Moved constants addition
        if r < (R_P - 1):
            round_constants_round_counter += 1
            state_words[0] = state_words[0] + round_constants_field_new[round_constants_round_counter][0]

        # Optimized multiplication with cheap matrices
        state_words = cheap_matrix_mul(state_words, v_collection[R_P - r - 1], w_hat_collection[R_P - r - 1], M_0_0)

    round_constants_round_counter += 1

    # Last full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    timer_end = time.time()
    
    return state_words

def perm_original(input_words):
    round_constants_field_new = [round_constants_field[index:index+t] for index in range(0, len(round_constants_field), t)]

    global timer_start, timer_end
    
    timer_start = time.time()

    R_f = int(R_F / 2)

    round_constants_round_counter = 0

    state_words = list(input_words)

    # First full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Middle partial rounds
    for r in range(0, R_P):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        state_words[0] = (state_words[0])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Last full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1
    
    timer_end = time.time()

    return state_words

# For checking optimized parameter code
M_i, v_collection, w_hat_collection = calc_equivalent_matrices()
#print('M_i', M_i)
#print('v_col', v_collection)
#print('w_hat_collection', w_hat_collection)

new_constants = calc_equivalent_constants(round_constants)
#[print(new_constants[index:index+t]) for index in range(0, len(new_constants), t)]

input_words = []
for i in range(0, t):
    input_words.append(F(i))

output_words = None
num_iterations = 1
total_time_passed = 0
for i in range(0, num_iterations):
    output_words = perm_original(input_words)
    #print(output_words)
    time_passed = timer_end - timer_start
    total_time_passed += time_passed
average_time = total_time_passed / float(num_iterations)
print("Average time for unoptimized:", average_time)

total_time_passed = 0
for i in range(0, num_iterations):
    opt_output_words = perm(input_words)
    #print(opt_output_words)
    time_passed = timer_end - timer_start
    total_time_passed += time_passed
average_time = total_time_passed / float(num_iterations)
print("Average time for optimized:", average_time)

# Check optimized is equal to the unoptimized
assert opt_output_words == output_words
