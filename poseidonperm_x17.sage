# Modified from Appendix B in the Poseidon paper, width 3 hash for BLS12-377
import time

# M is the targeted security level
M = 128
alpha = 17
t = 3
prime = 8444461749428370424248824938781546531375899335154063827935233455917409239041
F = GF(prime)
R_P = 31
R_F = 8
R_f = R_F / 2
R_T = R_F + R_P

# Omega is the linear algebra constant
# See Poseidon paper p. 24
# Varies between 2-3, here we assume $\omega=2$
omega = 2

# d in the paper is alpha for us
# D is the F_q vector space dimension
d = alpha

def resist_eigenpolynomial_computation(r_in, r_out):
    D = d ** (2 * r_in * R_f + R_P)
    # r_in is the input rate of poseidon
    # kappa in the paper is the targeted security level, M here
    print((log(min(r_in, r_out),2).n() + omega * log(D, 2)).n())
    return (log(min(r_in, r_out),2).n() + omega * log(D, 2)).n() >= M

print("instances secure vs iacr/2024/310 generic eigenpolynomial computation?")
print(resist_eigenpolynomial_computation(2, 1))
print(resist_eigenpolynomial_computation(3, 1))
print(resist_eigenpolynomial_computation(4, 1))
print(resist_eigenpolynomial_computation(6, 1))
print(resist_eigenpolynomial_computation(7, 1))
print(resist_eigenpolynomial_computation(8, 1))

def resist_root_extraction(r_in):
    D = d ** (2 * r_in * R_f + R_P)
    q = log(prime, 2)
    if D <= q:
        return (D * log(D) * log(log(D)) * (log(D) + log(q))).n() >= M
    else:
        return (q * log(q) * log(log(q)) * (log(q) + log(D))).n() >= M

print("instances secure vs iacr/2024/310 generic root extraction?")
print(resist_root_extraction(2))
print(resist_root_extraction(3))
print(resist_root_extraction(4))
print(resist_root_extraction(5))
print(resist_root_extraction(6))
print(resist_root_extraction(7))
print(resist_root_extraction(8))

round_constants = [308026635595114235070436728341841505234226384644787941764356225291780075012,
686850750308311448868354907988153221833589417264043199872750834851275630399,
5458865526113744175375673481036999502881423789202235030915223710930508573500,
1216889461603982466063117074419064018993731784023337352219629352951004218382,
4580374146984258872617301222640071415348151863297599652351895199406510624060,
5287771711632967718595430906600106184880872479312192055075552617141548501299,
3037526442503690560777271665669625925917538366486234291090702161060916614832,
6275277408809697928512465960441767403986852341417079924634963619646806124417,
7335650489313165022076032570688161581492191665821494053773844209042883340886,
1627952039309156476645184308670263708019542166435650091304574646631569460339,
6094265973203525089006037274771888959193635664689776329087130682272196094008,
6490696528492405721785907440795129872072544933360586449368276289112880330670,
1838969713611020994526552299650788115168140980815959904769759411371437475085,
2150051935070463751493305482799641725706245753717668882294497822824388319578,
4575572148360756475907353900681447955312802247778987169199474643005130716935,
1851688896784243289932019446285888654652306219713142676419351172260600922714,
6973552312635424934570970915726931835821737587964001373829651198305564713244,
1813003948570365248649794664717915544584605337173583303735237517614852010262,
8263838364638315756819655988900910418618512340908078920307324632543945164500,
757943113036795101065823745544829115197604837832768830141778672857097207622,
659325027542376965992085727974783614933698097545036724992593606308630964139,
1225384975372888789772257703659435489309718895398738845602578994965191972389,
7047321089114218473742436051763144729708458704973957631376463469541098276305,
4896435516099794294013100518299784209896728776935133585568100103105644366269,
2205611631605917342771043739003168054091728635889814050523595535007173267903,
4474292819278150418223394712870944390214136577384608881113789172943901756185,
5587482766701385940251260739243227887661785673403464848010833438080581211679,
2641477529317380932697589512697916502009860625009330516388196585651681493176,
7659241781098366386155720168632612014434481871232768282168172586344498585340,
2213394414496632001850413419138630033341488354994088997070037377687913045198,
8225722503382752487995602487837074631802103163654291534420243738097561923211,
7339897388607796780814184350408038307549544998106959208719480969830754355714,
6063557771009805901369588877386914456032427713266832819067913917532377663085,
5509459114334322933080334148673613015218318202961864814558888525860239977647,
1068773010324768699264514407746331217127187152280245817647555692667272524805,
1475085787102796648525415834131411151818489668007757976944301855541062325957,
7806695333926830350651265019724920668446960202327785464297697432575564892268,
6262615427970190003802435633045752362752019983944651481699206198107630667501,
5882310218697746646752824849544270655456741743515414997582197895094710858123,
4020331411826639688300623264550213776493766044074688280569180938277859091874,
5121255494220880264468029924121174240167067523779050306271979286616022983384,
845210955510933566002116427536045841286540286530946099066621065119722796675,
4111647319312005247588888076266870242762057231362139607364774953978018302987,
974256221217239393715990077542507764506970329207579698526122990643033824957,
8159194581608557426538516014063257877781718792172378782923721536338075157415,
5801330700370167469894729208361580066110395695280140377467309877650005609388,
3394916168528704906797115121684038788393911457592974647637601320052880312678,
5972250532491093184876275293339222434229671963274971711757113836479449305852,
577370828757987434131060765456679971208926305673729814931934265779321773430,
507369807706785879972719468470742776325023232536230874775576358969660471171,
8145685735375135873236047590991377004841377786797564751928308568246623719134,
6266812424655557804232577725379349619924941193610964604533176490248029261290,
5967069394383625926592344942286040375814323449026607622149927596188761075273,
3098449309447928770326430524623708251070761959504942163830346543311329812530,
7427687102404419444527513714902552301778528290974214220713506219999675675333,
4042876682716610044719894233707888314141403055770188287172821864822020198057,
6837118584037052064438949987261070301544840685414744015869031742089822922445,
1590095428593559863629820253130343351544841134884391502296948548443287186727,
7833716475035809798805452573207732340626115218296146847285921472768509634541,
1978766321165168589630826892562241348143601476846182828696106373368314589991,
7868843219594886750750407514795570643227076640179151649282544892407534950592,
3987117632709535432627489164941561521764371714110622944508310419066492323867,
4076651335938465583820584717335396202979827471201866993402454539589670076574,
6097748422352539177536678843480748867533252126316441163794334575472761192228,
6078805585843131510577316268189212746081092327434755953371890725413311537300,
808152962788527242286089686410977174198722494768279927846476444721346446780,
8245045639104682160533738142044010415064219273511255106133773733199124521153,
4927398668407453175049439565878572621130445066312119547147153299334208840274,
363071701490644073034803917900446378362169536640995003365310347872935927086,
6845633336116955356908527722458493089296092216721078117361029212334156034899,
5094161176623110722538832591662719638820846893811655692681247282139572370575,
7895316786827468299318427673897436206788315682717422447392995386534194809245,
4619732789620735261100885573296112045445141157388178713596060188742622627289,
8422122828670140480638067294204606309187570277720043969595883578063866777035,
992958244258733465815289318950280606760995861894444863716516601726621951905,
6764013719997591825457793918699801796014086921189886289817845875572992948924,
1769631866057478207885307356771710476532650071643225238577433500390003064798,
8016530745695127030799369163106442821010868795114179395122623057639374511985,
8047402967616037894798331978704326272668112374178700484265954166189443934757,
7958790794400926032963336530767233388628124879210206645872619788929075456478,
173252929061996890901264974543899995780593767283643983973014427458683001541,
424155452932847713908278173876758151545515219770842719961252496605244210819,
4963998855511100561599552018011798722633814204866173360361168413573963102186,
4924076301193420725308802072131338491797915911003604974321332671027931187176,
87738268021093433851281834491522887096402113566660018960879318272510245409,
8189285308779873224020359279990375150459733757976267012947719806969677070800,
7140245732247889400232233586175941378463217319557254345847453782157236936894,
3743951945863470078600584990270648056104210006488008873331665117840812797880,
7758108064106000033154897821365721729228420055510189063189732601086961159068,
2942331573871054342107123741050322394352958878052608362425041477010616345589,
7534481797769283402135041398750790178261361935710363254896834970993454697586,
7432765185094764662620235238828375611563632895456898300218670191109969003682,
6291527872301459316564295970257606704192931633697240620667776646184893228067,
5813315419101033685338589591740539737255593497183538450695253259569871183939,
5526672082176263237417520469010132662746348759226334285738656831590234548753,
3332801859738332252857912215019184013542060534668701681483001518406654964330,
1405201308866890283812006656161598509681885029723142585511085641864028595396,
1492494789956752741222490333391378456618539215379349797045428691266085997365,
8071212912433625994454068244446084774815031240954408676949101589537116165412,
4776554854519122517933592399764150620363707384114137316897908201016415856781,
125733739368601178383657902963503628562164711974256889561227003875613464767,
6095291956682197100095438891582653659020834282561205807326323590973913331048,
1222469665268606145803729120426500156401953546226735560453940247824615064170,
3553916981699410215413275982884160504425690320454695706786765040400435191673,
4597893035276850283590548632351419824369725156115729763845407308233992233881,
4098945751589637585349322721645137714901277398725764380413825257514636605490,
896241425392348667316141178956455644228372721471824108535546494759067376393,
3992502368943038378368897680594056578803163431114935312687627167974272071263,
2916896099606045408059702536614926909593404178656347225235372099792450298246,
120269880148157352408037220674298509372962320809264336091966259007633284713,
7722392890376228197239026921734213343834699657441777356614625170525296088221,
2433763979138972299522164212362097495457810156842620348670661190742330717004,
983738301417603757808483219105286248075595155162538643758190406964355750696,
209202405659177692545688490614016438006505568346018036573546364833013030573,
4653243085200282579438307546529783706597045845312243944557671219043378566385,
5337014110345479543678006017350943272815297410632902615031016645483782346794,
6325608705322012724565293795590543306557376953836287094512934948871034460300]

MDS_matrix = [[5629641166285580282832549959187697687583932890102709218623488970611606159361, 6333346312071277818186618704086159898531924501365547870951425091938056929281, 6755569399542696339399059951025237225100719468123251062348186764733927391233],
[6333346312071277818186618704086159898531924501365547870951425091938056929281, 6755569399542696339399059951025237225100719468123251062348186764733927391233, 7037051457856975353540687448984622109479916112628386523279361213264507699201],
[6755569399542696339399059951025237225100719468123251062348186764733927391233, 7037051457856975353540687448984622109479916112628386523279361213264507699201, 7238110070938603220784707090384182741179342287274911852515914390786350776321]]

MDS_matrix_field = matrix(F, t, t)

for i in range(0, t):
    for j in range(0, t):
        MDS_matrix_field[i, j] = F(MDS_matrix[i][j])

round_constants_field = []
for i in range(0, (R_F + R_P) * t):
    round_constants_field.append(F(round_constants[i]))

def calc_equivalent_constants(constants):
    constants_temp = [constants[index:index+t] for index in range(0, len(constants), t)]

    MDS_matrix_field_transpose = MDS_matrix_field.transpose()

    # Start moving round constants up
    # Calculate c_i' = M^(-1) * c_(i+1)
    # Split c_i': Add c_i'[0] AFTER the S-box, add the rest to c_i
    # I.e.: Store c_i'[0] for each of the partial rounds, and make c_i = c_i + c_i' (where now c_i'[0] = 0)
    for i in range(R_T - 2 - R_f, R_f - 1, -1):
        inv_cip1 = list(vector(constants_temp[i+1]) * MDS_matrix_field_transpose.inverse())
        constants_temp[i] = list(vector(constants_temp[i]) + vector([0] + inv_cip1[1:]))
        constants_temp[i+1] = [inv_cip1[0]] + [0] * (t-1)

    return constants_temp

def calc_equivalent_matrices():
    # Following idea: Split M into M' * M'', where M'' is "cheap" and M' can move before the partial nonlinear layer
    # The "previous" matrix layer is then M * M'. Due to the construction of M', the M[0,0] and v values will be the same for the new M' (and I also, obviously)
    # Thus: Compute the matrices, store the w_hat and v_hat values

    MDS_matrix_field_transpose = MDS_matrix_field.transpose()

    w_hat_collection = []
    v_collection = []
    v = MDS_matrix_field_transpose[[0], list(range(1,t))]
    M_mul = MDS_matrix_field_transpose
    M_i = matrix(F, t, t)
    for i in range(R_P - 1, -1, -1):
        M_hat = M_mul[list(range(1,t)), list(range(1,t))]
        w = M_mul[list(range(1,t)), [0]]
        v = M_mul[[0], list(range(1,t))]
        v_collection.append(v.list())
        w_hat = M_hat.inverse() * w
        w_hat_collection.append(w_hat.list())

        # Generate new M_i, and multiplication M * M_i for "previous" round
        M_i = matrix.identity(t)
        M_i[list(range(1,t)), list(range(1,t))] = M_hat
        M_mul = MDS_matrix_field_transpose * M_i
    return [M_i, v_collection, w_hat_collection]

def cheap_matrix_mul(state_words, v, w_hat, M_0_0):
    state_words_new = [0] * t
    column_1 = [M_0_0] + w_hat
    state_words_new[0] = sum([column_1[i] * state_words[i] for i in range(0, t)])
    mul_row = [(state_words[0] * v[i]) for i in range(0, t-1)]
    add_row = [(mul_row[i] + state_words[i+1]) for i in range(0, t-1)]
    state_words_new = [state_words_new[0]] + add_row
    return state_words_new

def perm(input_words):
    round_constants_field_new = calc_equivalent_constants(round_constants_field)
    [M_i, v_collection, w_hat_collection] = calc_equivalent_matrices()
    M_0_0 = MDS_matrix_field[0, 0]
    #[M_i, test_mat] = calc_equivalent_matrices()

    global timer_start, timer_end

    timer_start = time.time()

    R_f = int(R_F / 2)

    round_constants_round_counter = 0

    state_words = list(input_words)

    # First full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Middle partial rounds
    # Initial constants addition
    for i in range(0, t):
        state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]

    # First full matrix multiplication
    state_words = list(vector(state_words) * M_i)

    for r in range(0, R_P):
        # Round constants, nonlinear layer, matrix multiplication
        state_words[0] = (state_words[0])^alpha

        # Moved constants addition
        if r < (R_P - 1):
            round_constants_round_counter += 1
            state_words[0] = state_words[0] + round_constants_field_new[round_constants_round_counter][0]

        # Optimized multiplication with cheap matrices
        state_words = cheap_matrix_mul(state_words, v_collection[R_P - r - 1], w_hat_collection[R_P - r - 1], M_0_0)

    round_constants_round_counter += 1

    # Last full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    timer_end = time.time()

    return state_words

def perm_original(input_words):
    round_constants_field_new = [round_constants_field[index:index+t] for index in range(0, len(round_constants_field), t)]

    global timer_start, timer_end

    timer_start = time.time()

    R_f = int(R_F / 2)

    round_constants_round_counter = 0

    state_words = list(input_words)

    # First full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Middle partial rounds
    for r in range(0, R_P):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        state_words[0] = (state_words[0])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Last full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    timer_end = time.time()

    return state_words

# For checking optimized parameter code
M_i, v_collection, w_hat_collection = calc_equivalent_matrices()
#print('M_i', M_i)
#print('v_col', v_collection)
#print('w_hat_collection', w_hat_collection)

new_constants = calc_equivalent_constants(round_constants)
#[print(new_constants[index:index+t]) for index in range(0, len(new_constants), t)]

input_words = []
for i in range(0, t):
    input_words.append(F(i))

output_words = None
num_iterations = 1
total_time_passed = 0
for i in range(0, num_iterations):
    output_words = perm_original(input_words)
    print(output_words)
    time_passed = timer_end - timer_start
    total_time_passed += time_passed
average_time = total_time_passed / float(num_iterations)
print("Average time for unoptimized:", average_time)

total_time_passed = 0
for i in range(0, num_iterations):
    opt_output_words = perm(input_words)
    print(opt_output_words)
    time_passed = timer_end - timer_start
    total_time_passed += time_passed
average_time = total_time_passed / float(num_iterations)
print("Average time for optimized:", average_time)

# Check optimized is equal to the unoptimized
assert opt_output_words == output_words
