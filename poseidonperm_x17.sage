# Modified from Appendix B in the Poseidon paper, width 3 hash for BLS12-377
import time

# M = 128
alpha = 17
t = 3
prime = 8444461749428370424248824938781546531375899335154063827935233455917409239041
F = GF(prime)
R_P = 31
R_F = 8
R_f = R_F / 2
R_T = R_F + R_P

round_constants = [6988674540205220184161726804233283990758776299863834762040727861674579978543, 7709355290596865338819285880138672457952222650642807855871317708209074795474, 5201859429164217460310636175253377554540105593885866289756080180570368021951, 3049272212137844517764629946141402720245409346788255860423236916151652752101, 731916334316210902202615695074797267498900349008237468358490947620590797518, 6948583625231201615547345467810234311420481469329722516969162382644726485729, 4490233413574409524500190972213779994057100500913568615764229347275941966621, 7396725314962185388189273989459617572911903025336675876756586397590970741108, 2921080621736132447186011889175418237339394704314886136898495644039034276407, 6913381781295218724328701128337217653607031228663005211451263519103715771612, 6019749413834726725125133350812094485497924094481882289540053799149578344435, 4995954379914570178339745532281620079808702064916164361475898096048200561372, 2124186257537670932969443833628233916733000677872857619541493107812792994523, 7291894998836603209561258041480148233381540517628859681460511619998064153371, 5595990839755855325412866122463078686618808871960757703224904955947571683941, 3537160744846065764853442834424373409651099344521970876522694695688635431066, 2954454393932196948837847149102865937129021962377785175174024254914865842950, 3419315454849124650955009016912883940563484976972042083416858065603689496832, 3806428962945994811285946499090572627057499235956685241206402009333505759334, 3655799702308860920150435964548684891924451400804361135118484032125032598324, 57737751276368877857810935409958008964192913848302491350608849486103983184, 1915352583171320491693476119325069346845301615295456446193205432443729561362, 2439099701581451517688611628866569838452290241832250324455500902329843312702, 3989571287747866024297797480724745501265526459123523685165003532225058737017, 1274924313387817773523400448046659551605515353388015126322854352407485112178, 3538669999602770503695742207889860045394526991617705488296801358914185373580, 4401246357543850671767985325237453838498116603536497735906663351268804787461, 2559931452913074589872846458947462311744881462782273449825347290996535688190, 6709521882202160521710551267237866546258896928898102819308145878147110518998, 5373659760438588578295511027961568043615652955303420550992405255631014932790, 725358525431579200553169280129018217996979382272885300053580199941855247992, 2711677001259335480652195803065886043768935709346683926524369693602617098735, 2408404230388232206949522040212171032284939854972285633012212391817981607424, 1186040856650308375741364762182204898851227330889696264228020657476066439165, 404048178770844833884453808764026962014273331076560849830986302265017106597, 2457980758089805065016437725693167787523563267321442504443061210915487649059, 5514274238964078455104632169285419111957737803766043587115323546343949215185, 3514161082841676985857208649335676975188369868905520521318398127572664738752, 4108606834385867504687843217967114460156551001086842181166717914958770403973, 5438721170688670872528545023231974923420840584558594500405263452933878597229, 6906803554484917017200648665851986247523920135603718330373990427890960021429, 6773035949923635323431262859887753205922948876714484737222475796787366079632, 3454971734297107006829739591921250454837247155475050149046396338839813827731, 7364032274856046959988795104383399903833800495311645692576575019328860184739, 5090237262483125352320655316341291877320873702136810598778253319493729243907, 7040120647987711630185190920784851183122824396905398949829112552524922679218, 4241891765467070847114454202066467844546553548806051107324396246546372885021, 6665724400861899002873469039341765913644184695826421778987889913774443050629, 448984649713630578678620739597247393633758724695886660688385072842799016614, 4434682947538329726016505926721387004929017738396457187963678107139068894056, 2654258244823582020535836788585799851074201403680932834327618688807205649978, 7484689857886884960106141392369393095782615310091894042146328394047426518295, 1942808122528887865767961865820464537056521500030908110050474926722380974536, 344500957117500326028440473175755048870611851993354332374666161841080990947, 1348753541337083272549863328453752683182456212379425100821691332950288890545, 2103120456984437560455082748913176416990508871567415467939358228479854873351, 2292487208919231486153548864499042965890939794407917482440372775098861562679, 1365699813546208177056843640862540504179044968814663626900897795677799625494, 554977209842623516366328363486656166750217005493097317657821483311016867413, 1012681193481555714661518733220331453247456054885234525983936184818341343897, 3305231045599338776935501761324268246527607870853973257592166741567433374268, 4333877142094417744543077252413871656342262693613730620256227581042655305040, 7777205595073057350341784461834122331280415876029900939355522841662553176074, 4840858193637471129175745899503372456399630245018875386440469738656870783875, 2357676262748466822692807611262394405661835004883989150221401275910658221228, 7138273365000097744458577312541388740679989009422469449074028991224530604110, 485222390469261989303933907410224709686194360288659813320551592057697628336, 7304958057900576070706128694370846314753153242043556416488585921869990369553, 3054467536201050922565505407948114813542310872122046019653899354152048288587, 7927675397895965640682713824032195188375176019096874428380360918067593464293, 3309166302328489226253405730527865569800263915453313231389661384029388882973, 5965181721075655108229190542103190613948317087222615157537864954626934864278, 957462211078758382242413107792211135057848138559926337013021595366339577571, 198394403445445094359605615633590149332163797064329315770623355539242216309, 7463441484178016758773883131885464175931400841696025127277747424209731401404, 1160008805772248955377018833258451135257551662316808536058738978750378488011, 6518867743477019502219001069731966409833247292912334665417290659645667419955, 4517402679218052541576445358797485968486830057222997594823371950017329219302, 7354051301247770797842924589966697851909586702696257558683248998739487980604, 2834375192758634622309272728723360761307832547975462365181375869489140229995, 1994807436087186458521900248214366799099575848384138696628801997707644700762, 950692684046029615900460675185564728767691772421333563597409970862081455788, 215771305218329617432990321236383072164889337755200953331015221695765976106, 1909082095837831920888969082647459710433093968000148124011736509696807856013, 1598410195308242153466832582031632291180140534335578365097402262810462732055, 2678636807928147586414144012517644559789125698464788308292276107901313107661, 2917629436003252386224521387413944523909700127328145715767033623759922640382, 7458105141931924735314567432007818081713439243280961865780616542121851581718, 319795528388431346122583308065003312516920956910650811136638838518508986081, 2517244350831517565417121786113573693537264283492623928559027525769451471491, 223748040659454085763954561101046640414444944211485063723474905397991588694, 1192354867122687562579528359864247611894736623206207907228980319561228918703, 5871606971691538257906858052588972373505540906214016444548178191880980798796, 1571273754249990281688882673201310460162825990479829590740008610709340403068, 2553543928459081247552273773225408195006316644760016294757814926570104869, 2693467272792735502580627823871051010043382942662978686835727944408814177655, 6232251062757461771569898005064188756842484962202452339030167813201019698981, 2844452341053596785360832413947111911561976463007641674282907958850438543223, 4023368764458147563807714263192855312391442602065820814075304547101108205563, 8351301538936731390668124977528070777737461810842984866782766995293383324685, 5967036046303739940917424941967733943799255311341525764368533815862525175750, 5821507194266555565027704367793767940447847023791990834401931238817427202054, 2990863033217492956732717655690939068374085775072969350617575349863187663706, 5692143526394876476290802203580121735276368976431591727856389066872799499270, 1069795988224896959555747686619664343779988137540592094419890568097578384732, 3224051331877783069937246154883192018725119865352760355089784651290920906906, 6344299245364913590728081469479468396346568591287952250450228130036748752624, 7163298144698758147180460135771716060107526826354172769438296931285647166270, 5439669811527007432129035770771078324065108376477325977772842645864184474263, 2388540132512935462910769151388489826759515381039083966425687579783397147680, 5552242451981337643030834536688771349936013591654366196694153732254259211846, 2293718155480151242211995443457360332861427853767599092412745658932866271280, 1114026302922263706493655417918518257260056401972366120358912283469308695784, 8382504281541902573191937024713512277106734793833129272685742500601751387802, 7918246066354990409761145553536472732928632746154569124091286249273194443468, 1937283435333591890382964471447412728772736446554658078729798048971164286629, 2653607876727675876560671684767499894868406286850781422102673956317680932197]
MDS_matrix = [[5629641166285580282832549959187697687583932890102709218623488970611606159361, 6333346312071277818186618704086159898531924501365547870951425091938056929281, 6755569399542696339399059951025237225100719468123251062348186764733927391233], 
[6333346312071277818186618704086159898531924501365547870951425091938056929281, 6755569399542696339399059951025237225100719468123251062348186764733927391233, 7037051457856975353540687448984622109479916112628386523279361213264507699201],
[6755569399542696339399059951025237225100719468123251062348186764733927391233, 7037051457856975353540687448984622109479916112628386523279361213264507699201, 7238110070938603220784707090384182741179342287274911852515914390786350776321]]

MDS_matrix_field = matrix(F, t, t)

for i in range(0, t):
    for j in range(0, t):
        MDS_matrix_field[i, j] = F(MDS_matrix[i][j])

round_constants_field = []
for i in range(0, (R_F + R_P) * t):
    round_constants_field.append(F(round_constants[i]))

def calc_equivalent_constants(constants):
    constants_temp = [constants[index:index+t] for index in range(0, len(constants), t)]

    MDS_matrix_field_transpose = MDS_matrix_field.transpose()

    # Start moving round constants up
    # Calculate c_i' = M^(-1) * c_(i+1)
    # Split c_i': Add c_i'[0] AFTER the S-box, add the rest to c_i
    # I.e.: Store c_i'[0] for each of the partial rounds, and make c_i = c_i + c_i' (where now c_i'[0] = 0)
    for i in range(R_T - 2 - R_f, R_f - 1, -1):
        inv_cip1 = list(vector(constants_temp[i+1]) * MDS_matrix_field_transpose.inverse())
        constants_temp[i] = list(vector(constants_temp[i]) + vector([0] + inv_cip1[1:]))
        constants_temp[i+1] = [inv_cip1[0]] + [0] * (t-1)

    return constants_temp

def calc_equivalent_matrices():
    # Following idea: Split M into M' * M'', where M'' is "cheap" and M' can move before the partial nonlinear layer
    # The "previous" matrix layer is then M * M'. Due to the construction of M', the M[0,0] and v values will be the same for the new M' (and I also, obviously)
    # Thus: Compute the matrices, store the w_hat and v_hat values

    MDS_matrix_field_transpose = MDS_matrix_field.transpose()

    w_hat_collection = []
    v_collection = []
    v = MDS_matrix_field_transpose[[0], list(range(1,t))]
    M_mul = MDS_matrix_field_transpose
    M_i = matrix(F, t, t)
    for i in range(R_P - 1, -1, -1):
        M_hat = M_mul[list(range(1,t)), list(range(1,t))]
        w = M_mul[list(range(1,t)), [0]]
        v = M_mul[[0], list(range(1,t))]
        v_collection.append(v.list())
        w_hat = M_hat.inverse() * w
        w_hat_collection.append(w_hat.list())

        # Generate new M_i, and multiplication M * M_i for "previous" round
        M_i = matrix.identity(t)
        M_i[list(range(1,t)), list(range(1,t))] = M_hat
        M_mul = MDS_matrix_field_transpose * M_i
    return [M_i, v_collection, w_hat_collection]

def cheap_matrix_mul(state_words, v, w_hat, M_0_0):
    state_words_new = [0] * t
    column_1 = [M_0_0] + w_hat
    state_words_new[0] = sum([column_1[i] * state_words[i] for i in range(0, t)])
    mul_row = [(state_words[0] * v[i]) for i in range(0, t-1)]
    add_row = [(mul_row[i] + state_words[i+1]) for i in range(0, t-1)]
    state_words_new = [state_words_new[0]] + add_row
    return state_words_new

def perm(input_words):
    round_constants_field_new = calc_equivalent_constants(round_constants_field)
    [M_i, v_collection, w_hat_collection] = calc_equivalent_matrices()
    M_0_0 = MDS_matrix_field[0, 0]
    #[M_i, test_mat] = calc_equivalent_matrices()
    
    global timer_start, timer_end

    timer_start = time.time()

    R_f = int(R_F / 2)

    round_constants_round_counter = 0

    state_words = list(input_words)

    # First full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Middle partial rounds
    # Initial constants addition
    for i in range(0, t):
        state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]

    # First full matrix multiplication
    state_words = list(vector(state_words) * M_i)

    for r in range(0, R_P):
        # Round constants, nonlinear layer, matrix multiplication
        state_words[0] = (state_words[0])^alpha

        # Moved constants addition
        if r < (R_P - 1):
            round_constants_round_counter += 1
            state_words[0] = state_words[0] + round_constants_field_new[round_constants_round_counter][0]

        # Optimized multiplication with cheap matrices
        state_words = cheap_matrix_mul(state_words, v_collection[R_P - r - 1], w_hat_collection[R_P - r - 1], M_0_0)

    round_constants_round_counter += 1

    # Last full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    timer_end = time.time()
    
    return state_words

def perm_original(input_words):
    round_constants_field_new = [round_constants_field[index:index+t] for index in range(0, len(round_constants_field), t)]

    global timer_start, timer_end
    
    timer_start = time.time()

    R_f = int(R_F / 2)

    round_constants_round_counter = 0

    state_words = list(input_words)

    # First full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Middle partial rounds
    for r in range(0, R_P):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        state_words[0] = (state_words[0])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1

    # Last full rounds
    for r in range(0, R_f):
        # Round constants, nonlinear layer, matrix multiplication
        for i in range(0, t):
            state_words[i] = state_words[i] + round_constants_field_new[round_constants_round_counter][i]
        for i in range(0, t):
            state_words[i] = (state_words[i])^alpha
        state_words = list(MDS_matrix_field * vector(state_words))
        round_constants_round_counter += 1
    
    timer_end = time.time()

    return state_words

# For checking optimized parameter code
M_i, v_collection, w_hat_collection = calc_equivalent_matrices()
#print('M_i', M_i)
#print('v_col', v_collection)
#print('w_hat_collection', w_hat_collection)

new_constants = calc_equivalent_constants(round_constants)
#[print(new_constants[index:index+t]) for index in range(0, len(new_constants), t)]

input_words = []
for i in range(0, t):
    input_words.append(F(i))

output_words = None
num_iterations = 1
total_time_passed = 0
for i in range(0, num_iterations):
    output_words = perm_original(input_words)
    #print(output_words)
    time_passed = timer_end - timer_start
    total_time_passed += time_passed
average_time = total_time_passed / float(num_iterations)
print("Average time for unoptimized:", average_time)

total_time_passed = 0
for i in range(0, num_iterations):
    opt_output_words = perm(input_words)
    #print(opt_output_words)
    time_passed = timer_end - timer_start
    total_time_passed += time_passed
average_time = total_time_passed / float(num_iterations)
print("Average time for optimized:", average_time)

# Check optimized is equal to the unoptimized
assert opt_output_words == output_words
